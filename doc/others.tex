\chapter{Implementaciones clásicas}

\begin{chapquote}{Emile Michel Cioran, \textit{Silogismos de la amargura}}
Sólo los espíritus agrietados poseen aberturas al más allá.
\end{chapquote}

En principio, se ha elaborado un prototipo en \textit{Haskell} del algoritmo \textit{DPLL}, usando la representación \textit{CNF} y otro para la conversión de fórmulas proposicionales a \textit{BDDs}. Ambos usando como base el mismo modelo de representación para la proposiciones lógicas usando tipos de datos algebraicos, pero realizando una un proceso de conversión diferente. Esto con el objetivo de tener una prueba conceptual de soluciones que existen actualmente para \sat.

\section{Proposiciones lógicas en \textit{Haskell}}
\label{sec:data}

Como primer paso se ha decidido representar a las proposiciones lógicas en \textit{Haskell} de forma arborescente, con un tipo de dato algebraico recursivo que puede verse en la figura \ref{code:prop}. En donde se han definido operadores, que son realmente constructores del tipo, y tienen una precedencia asignada que va en concordancia con la de los operadores lógicos de conjunción (\texttt{:\&:}), disyunción (\texttt{:|:}), implicación (\texttt{:>:}) y equivalencia (\texttt{:=:}). La negación posee un constructor usual y al igual que las sentencias de la proposición. A partir de esta definición se basan todos los algoritmos que se han implementado y resulta la forma más natural de hacerlo en \textit{Haskell}.

\begin{figure}
\begin{lstlisting}[language=Haskell]
    data Prop a
        = (Prop a) :&: (Prop a)
        | (Prop a) :|: (Prop a)
        | (Prop a) :>: (Prop a)
        | (Prop a) :=: (Prop a)
        | Neg (Prop a)
        | Stmnt a
\end{lstlisting}
\caption{Tipo de dato \textit{Haskell} para proposiciones lógicas}
\label{code:prop}
\end{figure}

\section{\textit{CNF}}

Esta representación separa a una fórmula lógica en cláusulas operadas por la operación ($\land$), reduciendo el problema \sat a buscar la cláusula que no se cumpla dada cierta asignación de valores booleanos a las variables. Es evidente que se irían verificando las cláusulas hasta que alguna falle, en ese momento se sabría que esa combinación de valores para la proposición no es satisfactible. El proceso de normalización comienza obteniendo la forma normal negativa de la proposición lógica para luego aplicar la propiedad distributiva del ($\lor$) sobre ($\land$) hasta que no se pueda aplicar más. El algoritmo \textit{DPLL}, que está basado en el comportamiento de \textit{CNF}, se enuncia a continuación.

\subsection{\textit{DPLL}}

El algortimo \textit{Davis–Putnam–Logemann–Loveland} (\textit{DPLL}) realiza una busqueda usando \textit{backtracking}, donde en cada paso hay una toma de desición y comprobación de las cláusulas que conforman a la proposición lógica. La implementación en \textit{Haskell} reside en una función que se llama recursivamente tomando una desición en cada paso y aporvecha la evaluación perezosa para dividir desiciones de asignación binaria en una simple disyunción.

\section{\textit{BDDs}}

Los diagramas binarios de desición (\textit{BDDs}) es una representación útil porque resulta ser incremental, se pueden operar entre ellos y reproducir un nuevo \textit{BDD}, el cual tendrá las restricciones de ambos dependiendo del operador que se haya usado; manteniendo orden y unicidad. Comportamiento compartido con el polinomio de \textit{Zhegalkin}. Los \textit{BDDs} pueden tener muchas utilidades, ya que indican facilmente si una proposición lógica se satisface o no, asi como los valores necesarios para que se satisfga. Pero en lo que se refiere a \sat, resulta costoso mantener una estructura arborescente ordenada y dado que el objetivo es paralelizar procesos, no se consideró oportuno como una opción para implementar con OpenCL.
